import re

inputAssemblyFile = "inp.asm"

# MOT stores length and opcode


MOT = {
    "READ": ("09", "1"),
    "MOVER": ("04", "3"),
    "MOVEM": ("05", "3"),
    "ADD": ("09", "3"),
    "COMP": ("06", "3"),
    "BC": ("07", "2"),
    "PRINT": ("10", "1"),
    "STOP": ("00", "1"),
    "LE": ("17", "1"),
    "LT": ("18", "1"),
}

POT = {
    "START": "01",
    "END": "02",
    "DS": "03",
    "DC": "04"
}

REGT = {
    "AREG": "R01",
    "CREG": "R03"
}


def imperativeStmt(line):
    for i in line:
        if i in MOT:
            return (True, i)
    return (False, None)


def declarativeStmt(line):
    for i in line:
        if i in POT:
            return (True, i)
    return (False, None)


# Searches for a literal in a line
patLiteral = re.compile("'(\w)'")
patConstant = re.compile("\d+")

# To be generated by pass one
SYMT = {}   # SYM: {value, LC}
LITT = {}   # LIT: {LC}

LC = 0


def passOne():
    global LC
    f = file(inputAssemblyFile, "r")
    for i in f.readlines():
        line = i.split()

        if 'START' in line:
            LC = int(line[-1])
            # Assuming program has been writtem from first address
            SYMT['START'] = (500, 0)

        else:
            if imperativeStmt(line)[0]:
                instruction = imperativeStmt(line)[1]
                LC += int(MOT[instruction][0])

                # In imperativeStmt A symbol/label has a value equal to its LC
                # Value

            if declarativeStmt(line)[0]:
                instruction = declarativeStmt(line)[1]

                # In declarativeStmt A symbol/label has a value equal to
                # constant/literal

            # Now parse line for literals and symbols
            for token in line:
                if token not in MOT and token not in POT:
                    # it's either a symbol or a literal or a register
                    if patLiteral.match(token):
                        if token not in LITT:
                            LC += 1
                            LITT[token] = LC
                    else:
                        # We have a symbol
                        if patConstant.match(token) or token in REGT:
                            continue

                        if token not in SYMT:
                            LC += 1
                            SYMT[token] = ("Address", LC)  # no value initially
                        else:
                             # symbol has been defined before. Set it's value
                             # here whether it's a DECLARATIVE or IMPERATIVE
                            oldLC = SYMT[token][1]
                            if declarativeStmt(line)[0]:
                                isLit = patLiteral.search(i)
                                isConst = patConstant.search(i)
                                if isLit:
                                    SYMT[token] = (
                                        "'%c' " % (isLit.groups()[0]), oldLC)

                                elif isConst:
                                    SYMT[token] = ("Const", oldLC)

    print '\n\n\n******SYMTAB: *******'
    for i in SYMT:
        print i, ':\t\t', SYMT[i]
    print '*********************'

    print '\n\n******LITTAB: *******'
    for i in LITT:
        print i, ':\t\t', LITT[i]
    print '*********************'

    f.close()


def passTwo():
    """Compute object code"""
    # Object Code: Location, Operand Code, Mnemonic opcode, length
    global LC
    print '\n*******OBJECT CODE*********'
    f = file(inputAssemblyFile, "r")
    for i in f.readlines():
        line = i.split()

        if 'START' in line:
            LC = int(line[-1])

        else:
            if imperativeStmt(line)[0]:
                instruction = imperativeStmt(line)[1]
                LC += int(MOT[instruction][0])
                print LC, '\t\t', instruction,  '\t\t', MOT[instruction][1], '\t\t',

            if declarativeStmt(line)[0]:
                instruction = declarativeStmt(line)[1]
                LC += 1
                print LC, '\t\t', instruction,  '\t\t', POT[instruction], '\t\t',

            # Now scan rest of line for operands
            for token in line:
                if token not in MOT and token not in POT:
                    # it's either a symbol or a literal or a register
                    if token in REGT:
                        print REGT[token], '\t\t',

                    if patLiteral.match(token):
                        print LITT[token], '\t\t',
                    else:
                        # It's a symbol:
                        if token not in SYMT:
                            continue
                        elif SYMT[token][0] == "Address":
                            print SYMT[token][1], '\t\t',
                        else:
                            print SYMT[token][0], '\t\t',
            print
    f.close()
    print '\n*********************\n\n'


if __name__ == '__main__':
    # Objective 1: Create a symbol table
    # Objective 2: Create the literal table
    # Objective 3: Create the object code. Requires 2 passes
    print "\n Running Pass One: \n"
    passOne()

    print "\n Running Pass Two: \n"
    passTwo()
    print "\n Pass Two Over"
